# 1043.Partition Array For Maximum Sum

(1043.Partition Array For Maximum Sum) [https://leetcode.com/problems/partition-array-for-maximum-sum/description/] প্রব্লেমের বর্ণনায় বলা হয়েছে আমাদের একটি আরে দেওয়া আছে। এই অ্যারেকে আমরা কতগুলি পরপর সাবঅ্যারেতে ভাগ করতে পারি এবং প্রত্যেক সাবঅ্যারের ভ্যালুগুলোকে ঐ সাব অ্যারের সর্বোচ্চ ভ্যালু দিয়ে প্রতিস্থাপন করে সবগুলোর যোগফল সর্বোচ্চ কত পেতে পারই। এখানে অবশ্যই প্রত্যেক সাবঅ্যারেতে k সংখ্যক ভ্যালুর বেশি হওয়া যাবে না এবং সাব অ্যারেগুলো পরপর হতে হবে অর্থাৎ ওভারল্যাপ হওয়া যাবে না। যেমন আমাদের একটি অ্যারে আছে এমন [1, 15, 7, 9, 2, 5, 10] এবং k = 3. তাহলে আমরা এভাবে ভাগ করতে পারি [1, 15, 7], [9 ], [2 , 5, 10] এবং প্রত্যেক সাবঅ্যারের সর্বোচ্চ ভ্যালু দিয়ে প্রতিস্থাপন পাই [15, 15, 15], [9 ], [10, 10, 10] । এর উত্তর হচ্ছে 15+15+15 +9 + 10+10+10 = 84 .

এই প্রব্লেমটি আমরা ডিপি দিয়ে সহজে সলভ করতে পারি।
এখানে যতভাবে পার্টিশন করা যায় আমরা সবগুলো পসিবল পার্টিশন নেওয়ার চেষ্টা করবো যাতে সর্বোচ্চ যোগফল পেতে পারি । তবে আমরা উলটো দিক থেকে উত্তর বের করার চেষ্টা করবো। অর্থাৎ প্রথমে n-1 এর জন্য সমাধান করবো, এরপর n-2, এরপর n-3, এভাবে n-4,...,2,1,0 পর্যন্ত । 
তাহলে আমরা একটি i নিই যেটা n-1 থেকে 0 পর্যন্ত ঘুরবে। 
এখন মনে করো আমাদের i তম মানটি বের করতে হবে এবং এর পূর্বের অর্থাৎ n তম, n-1 তম, ..., i+1 তম যারা ছিলো তাদের সমাধান হয়ে গেছে। পরবর্তী i, i-1, ..., 2, 1, 0 গুলোর সমাধান বের করতে হবে। তাহলে আমরা এখন কি করতে পারি? 
জাস্ট i থেকে j=i তম পজিশনটাকে একটা পার্টিশন ধরি যার উপাদান সংখ্যা 1 টি । যেহেতু i+1 তম পজিশনে আমার অলরেডি সল্যুশন আছে। কাজেই এখন i থেকে i পার্টিশনের ম্যাক্সিমাম ভ্যালু বের করি। তাহলে আমাদের উত্তর হবে dp[i] = dp[j+1]+mx*1। আবার i থেকে j=i+1 তম একটা পার্টিশন ধরি এবং মনে করি i+2 তে অলরেডি সল্যুশন আছে এবং i থেকে j=i+1 পার্টিশনের ম্যাক্সিমাম বের করি। তাহলে আমাদের আগের উত্তরটি চেঞ্জ হয়ে হবে dp[i] = max(dp[i], dp[i+2]+mx * 2). এভাবে আমরা i থেকে j=i+k পর্যন্ত একটা পার্টিশন নিতে পারি এবং মনে করি এর আগ পর্যন্ত অর্থাৎ j=i+k তে অপটিমাল সল্যুশন আছে। কাজেই আমাদের জেনারেল ফরমুলা হবে,
dp[i] = max(dp[i], dp[j+1]+mx*(j-i+1))
এখানে j হচ্ছে i থেকে j পর্যন্ত উপাদান নিয়ে একটা পার্টিশন করেছি। এবং ধরে নিয়েছি আমাদের তার সামনের অর্থাৎ j+1 পর্যন্ত সল্যুশন অলরেডি আছে। 
পুরো কোডটি হবে এরকমঃ
```
class Solution {
public:
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        int n = arr.size();
        int dp[n+1];
        memset(dp, 0, sizeof(dp));
        for(int i = n-1; i >= 0; i--){
            int mx = 0;
            int end = min(n, i+k);
            for(int j = i; j < end; j++) {
                mx = max(mx, arr[j]);
                dp[i] = max(dp[i], dp[j+1] + (j-i+1)*mx);
            }
        }
        return dp[0];
    }
};
```